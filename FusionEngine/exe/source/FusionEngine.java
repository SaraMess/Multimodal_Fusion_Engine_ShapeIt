/* autogenerated by Processing revision 1286 on 2022-11-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import fr.dgac.ivy.*;
import fr.dgac.ivy.tools.*;
import gnu.getopt.*;

import fr.dgac.ivy.*;
import java.io.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FusionEngine extends PApplet {

/*
 *  Multimodal fusion engine
 * v. 1.0
 * 
 * (c) Author: Sara Messara
 * Last Revision: 27.11.2022
 */
 



// data

Ivy bus;
PFont f;
String message= "";
String userFeed="";
FSM state; // Fusion Engine finite states machine
FusionData data; // I/O data structure
int order;
 public void setup()
{ 
  /* size commented out by preprocessor */;
  surface.setLocation(1390,880);
  // graphical display
  fill(0,0,0);
  surface.setTitle("Multimodalities Fusion Engine");
  // init 
  data = new FusionData(3);
  state = FSM.INIT;
  order = -1;
  try
  {
    bus = new Ivy("FusionEngine", "Multimodalities Fusion Engine (MFE) ready", null);
    bus.start("127.255.255.255:2010"); // Ip and port number
    
    // Ivy message subscriptions
    // Speech recognition
    // speech rejection
    bus.bindMsg("^sra5 Event=Speech_Rejected", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        if(data.doIListen()){
        state = FSM.REJECTION;
        data.feedUser = "Je suis dure d'oreille, pourriez vous répéter ?";
        }
        
      }        
    });
    
    // start signal
    bus.bindMsg("^sra5 Parsed=1 start=1 .*", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        order = 0;
        data.reset();
        data.startListen();  
        state = FSM.INIT;
        data.feedUser = "J attends que tu me dise \"Commence\" !";
        
      }        
    });
    
    bus.bindMsg("OneDollarIvy exit", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        exit();
      }        
    });
    
    // shutdown 
    bus.bindMsg("^sra5 Parsed=1 cocorico", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        if(data.doIListen())
        {
        data.stopListening();
        order = 0;
        data.reset();  
        state = FSM.EXECUTION;
        data.feedUser = "COCORICO !";
        try {
          bus.sendMsg("mfe cocorico"); 
          }
        catch (IvyException e) {}
        }
      }        
    });
    
    // coloring action
    bus.bindMsg("^sra5 Parsed=1 pointage=(.*) action=(.*) shape=(.*) color=(.*) colorN=(.*) Confidence=(.*) NP.*", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        println(data.doIListen());
        if(data.doIListen())
        {
        order = 1;
        println("reception colo");
        data.pointing = Boolean.valueOf(args[0]);
        data.recieved = true;
        data.action = args[1];
        data.shape[0]= args[2]; 
        data.c_rec[0] = args[3]; // color from speec 
        data.colorN = args[4];
        data.locate = false;
        data.confi[0] = Float.valueOf(args[5]);
        }
      }        
    });
    
    // actions apart from coloring
    bus.bindMsg("^sra5 Parsed=1 pointage=(.*) action=(.*) shape=(.*) color=(.*) localisation=(.*) Confidence=(.*) NP.*", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        println(data.doIListen());
        if(data.doIListen())
        {
        order = 1;
        println("reception colo loca");
        data.pointing = Boolean.valueOf(args[0]);
        data.recieved = true;
        data.action = args[1];
        data.shape[0]= args[2]; 
        data.c_rec[0] = args[3]; // color from speec 
        data.locate = Boolean.valueOf(args[4]);
        data.confi[0] = Float.valueOf(args[5]);
        }
      }        
    });
    
    bus.bindMsg("^sra5 Parsed=1 pointage=(.*) action=(.*) shape=(.*) localisation=(.*) color=(.*) Confidence=(.*) NP.*", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        if(data.doIListen())
        {
        println("reception loca colo");
        order = 2;
        data.pointing = Boolean.valueOf(args[0]);
        data.recieved = true;
        data.action = args[1];
        data.shape[0]= args[2]; 
        data.c_rec[0] = args[4]; // color from speec 
        data.locate = Boolean.valueOf(args[3]);
        data.confi[0] = Float.valueOf(args[5]);
        
        }
      }        
    });
    
    
    // 1$ recognition
    bus.bindMsg("^OneDollarIvy Template=(.*) Confidence=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        if(data.doIListen())
        {
        data.shape[1] = args[0];
        data.confi[1] = Float.valueOf(args[1]);
        }
      }        
    });
    
    // Board 
    bus.bindMsg("^Board shape=(.*) color=(.*) Confidence=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        if(data.doIListen())
        {
        data.from_palette_s.add(args[0]); // input shape
        data.from_palette_c.add(args[1]); // input color
        data.confi[2] = Float.valueOf(args[2]);
        println(data.from_palette_s.size());
        }
      }        
    }); 
    
    // palette execution feedback
    bus.bindMsg("^Board result=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client,String[] args)
      {
        data.result = args[0];
      }        
    });
    
  }
  catch (IvyException ie)
  {
  }
}

 public void draw()
{
  background(0);
  
  switch(state) {
    case INIT:
      // waiting start signal
      data.feedUser = "J attends que tu me dise \"Commence\" !";
      //println("here");
      text(data.feedUser, 20, 50);
      if(data.doIListen())
        {state = FSM.LISTENING;
        data.feedUser = "Je suis de toute ouie et de toute vue. Let's ShapeIt !";
        }
      break;
      
    case LISTENING:
      // listening to channels 
      data.feedUser = "Je suis de toute ouie et de toute vue. Let's ShapeIt !";
      text(data.feedUser, 20, 50);
      if(data.recieved) // wait reception from speech
        {
        data.dataWait(order); // blocking function
        println("still listen");
        if(data.allIn)
        {
          println("all input in");
          data.stopListening();
          if(data.noMatch)
            state = FSM.REJECTION;
          else 
            state = FSM.PROCESSING;
        }
        }
      break;
      
    case PROCESSING :
      // perform fusion
      data.feedUser = "J essaye de comprendre votre demande...";
      text(data.feedUser, 20, 50);
      data.dataFuse();
      text(data.feedUser, 20, 50);
      println("end fusion");
      // send instruction to Board
      data.dataSend();
      state = FSM.EXECUTION;
      break;
      
     case EXECUTION:
       // waiting feedback from Board
       data.feedUser = "J'ai compris ! Je m'exécute";
       text(data.feedUser, 20, 50);
       if(data.result !=""){
         data.reset();
         state = FSM.INIT;
         // send results of execution
          try {
            bus.sendMsg("mfe result of execution: " + data.result); 
            }
          catch (IvyException e) {}
          data.result = "";
       }
       break; 
       
     case REJECTION:
       // reset engine after speech rejection event
       data.feedUser = "Je n'ai pas compris... Je dois recommencer.";
       text(data.feedUser, 20, 50);
       data.reset();
       state = FSM.INIT; // need to say "commence" again
       try {
          bus.sendMsg("mfe event=abort"); 
       }
       catch (IvyException e) {}
       break;
  }
  background(232,232,232);
  text("** Mon état courant **", 100,20);
  /*if(state == FSM.INIT)
    text("J'attends que tu me dises \"commence\" ! ", 20, 50);
  if(state == FSM.LISTENING)
    text("Je t'écoute et te vois ! ", 20, 50);
  if(state == FSM.PROCESSING)
    text("J'essaye de comprendre ce que tu veux !" , 20, 50);
  if(state == FSM.EXECUTION)
    text("Oui chef !", 20, 50);
  if(state == FSM.REJECTION)
    text("Je ne t'ai pas bien entendu...", 20, 50);
    textSize(20);*/
    
  text(data.feedUser, 20, 50);
  if(!data.feedUser.equals(userFeed))
  {
    userFeed = data.feedUser;
  try {
          bus.sendMsg("mfe state="+data.feedUser); 
          }
        catch (IvyException e) {}  
  }
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 */
 
public enum FSM {
  INIT,  // waiting the start signal
  LISTENING, // listening to channels  
  PROCESSING, // data fusion
  EXECUTION, // waiting feedback from palette
  REJECTION // reinit engine after speech rejection event
   
}
public class FusionData {
  /** Data strucutre for multimodal inputs and outputs management
    */
  
  int numIn; // number of modalities 
  // internal flags
  boolean start; // initiate or not the fusion
  boolean recieved; // check complete speech reception
  boolean speCase; // indicate special cases (cf. report)
  boolean keepW; // keep waiting missing data
  boolean noMatch; // faulty input scenario
  // recieved data
  float[] confi; // confidence array for each input source [for this use case 0->Speech, 1-> One$, 2-> Palette]
  String[] shape; // shape array for each input source
  String[] c_rec; // color array for each input source 
  boolean locate; // location indication 
  boolean  pointing; // shape designation
  List<String> from_palette_s; // recieved shapes (speech - 1$Ivy - palette)
  List<String> from_palette_c; // recieved colors 
  // data to send 
  String shape2send; // shape to send to the palette
  String loca2send; //index of coordinates to send
  String c; // color to send to the palette 
  String result; // result of execution from palette
  String action;
  String exactShape; 
  String colorN;
  String feedUser;
  boolean allIn;
  boolean shapeIn;
 
  
  public FusionData(int numInput) {
    numIn = numInput;
    
    // init data
    noMatch = true;
    from_palette_s = new ArrayList<String>();
    from_palette_c = new ArrayList<String>();
    action="undefined";
    c="undefined";
    shape2send = "undefined";
    start = false;
    recieved = false;
    pointing = false;
    loca2send = "-9";
    exactShape = "";
    locate = false;
    result = "";  
    colorN = "";
    feedUser = "";
    shape = new String[numIn];
    confi = new float[numIn];
    c_rec = new String[numIn];
    keepW = true;
    speCase = false;
    allIn = false;
    shapeIn = false;
    for(int i=0; i<numIn; i++)
       {
        confi[i] = 0.0f;
        shape[i] = "undefined";
        c_rec[i] = "undefined";
       }
  }
  
   public void reset() {
    /** reset data
    */
      recieved = false;
       for(int i=0; i<numIn; i++)
       {
        confi[i] = 0.0f;
        shape[i] = "undefined";
        c_rec[i] = "undefined";
       }
      from_palette_s.clear();
      from_palette_c.clear();
      shape2send = "undefined";
      c = "undefined";
      speCase = false;
      allIn = false;
      shapeIn = false;
      keepW = true;
      loca2send = "-9";
  }
  
   public Boolean doIListen()
   /** is the engine intaking messages
  */
    {  return start;
     }
 
    public void stopListening()
   /** block messages reception
  */
   {  start  = false;
   }
 
    public void startListen()
   /** enable messages reception
  */
   {  start  = true;
   }
 
    public void dataWait(int order) 
   /** collect data from the multiple channels
  */{
   if(keepW)
   {  
     keepW = false;
     noMatch = false;
     if(!data.action.equals("o"))
     // studying cases when action != coloring 
     {
       if(data.pointing)
     // indicating a shape -- shape comes either from palette or from the 1$Ivy
     {  
        if(data.locate)
        {
          if(c_rec[0].equals("palette"))
          // color indicated in the palette
          {
            // cases depending of number of clicks in the palette
           switch(data.from_palette_s.size())
           {
             case 3:
            // color and shape from palette send localisation order
                 shape[2] = from_palette_s.get(0);
                 if(order == 1)
                 {
                   c_rec[2] = from_palette_c.get(1);
                   loca2send = "2";
                 }
                 else
                 {
                   c_rec[2] = from_palette_c.get(2);
                   loca2send = "1"; // the click to consider for the localisation
                 }
                 break;
            case 2:
                 
                 if(order == 1)
                 {
                   c_rec[2] = from_palette_c.get(0);
                   loca2send = "1";
                 }
                 else
                 {
                   c_rec[2] = from_palette_c.get(1);
                   loca2send = "0"; // the click to consider for the localisation
                 }
                 break;
             case 1:
                keepW = true;
                feedUser = "J attends que tu m'indiques la couleur ou la position. Encore un click !";
                println("stuck 1");
                break;
             case 0:
                keepW = true;
                feedUser = "J attends que tu m'indiques la couleur et la position. Encore 2 clicks !";
                println("stuck 1");
                break;
             default:
               keepW = false;
               noMatch = true;
               break;
          }
          }
        else 
          {  
           switch(from_palette_s.size()){
             case 2:
               shape[2] = from_palette_s.get(0);
               if(c_rec[0].equals("undefined"))
                 c_rec[2] = from_palette_c.get(0);
               loca2send = "1"; // the location
               if(!from_palette_s.get(0).equals("undefined") && !data.action.equals("c") && c_rec[0].equals("undefined"))
               {
                 speCase = true;
                 exactShape = "0";
                 println("special2");
               }
               break;
             case 1:
             loca2send = "0"; // the location
             break;
             case 0:
               keepW = true;
               println("stuck 2");
               feedUser = "J attends que tu m'indiques la position. Encore un click !";
               break;
             default:
               keepW = false;
               noMatch = true;
               feedUser = "Trop de clicks ! Je ne comprends pas, voulez vous recommencer ?";
               break;
          }
         }
        }
       else 
       {
         // location not indicated
      
          if(c_rec[0].equals("palette"))
          {
           switch(data.from_palette_s.size())
             {
             case 2:
               shape[2] = from_palette_s.get(0);
               c_rec[2] = from_palette_c.get(1);
               loca2send = "-9"; //random localisation
               break;
             case 1:
                c_rec[2] = from_palette_c.get(0);
                loca2send = "-9"; // random
                break;
             case 0:
               keepW = true;
               feedUser = "J attends la couleur. Encore un click !";
               println("stuck 3");
               break;
             default:
               keepW = false;
               noMatch = true;
               feedUser = "Trop de clicks ! Je ne comprends pas, je dois recommence.";
               break;
          }
          }
           else // pointing no color and no localisation
           {
             switch(data.from_palette_s.size())
             {
               case 1:
                  shape[2] = from_palette_s.get(0);
                  if(c_rec[0].equals("undefined"))
                    c_rec[2] = from_palette_c.get(0);
                  print("added");
                  loca2send = "-9"; // random
                  if(!from_palette_s.get(0).equals("undefined") && !data.action.equals("c") &&  c_rec[0].equals("undefined"))
                   {
                     speCase = true;
                     exactShape = "0";
                   }
                   break;
               case 0:
                 keepW = false;
                 break;
               default:
                 keepW = false;
                 noMatch = true;
                 feedUser = "Trop de clicks ! Je ne comprends pas, je dois recommence.";
                 break;
           }
        }
     }
     }
     else
     { // not pointing an object
       // shape given from 1$Ivy or speech only  
       if(data.locate)
       {  // not pointing and location indicated
           if(data.c_rec[0].equals("palette"))
           {
             switch(from_palette_s.size())
             {
               case 2:
                 if(order == 1)
                 {
                  c_rec[2] = from_palette_c.get(0);
                  loca2send = "1";
                 }
                 if(order == 2)
                 {
                  c_rec[2] = from_palette_c.get(1);
                  loca2send = "0";
                 }
                 break;
               case 1:
                  keepW = true;
                  println("stuck 5");
                  feedUser = "J attends que vous m indiquiez la localisation ou la couleur. Encore un click !";
                  break;
               case 0:
                  keepW = true;
                  feedUser = "J attends que vous m indiquiez la localisation et la couleur. Encore 2 clicks !";
                  println("stuck 5");
                  break;
               default:
                 keepW = false;
                 noMatch = true;
                 feedUser = "Trop de clicks ! Je dois recommencer.";
                 break;
              }
           }
           else
           {
             println(from_palette_s.size());
             if(from_palette_s.size()<1)
              { 
                keepW = true;
                feedUser = "J attends la localisation. Encore un click !";
              }
             else
               {
                loca2send = "0";
               }
           }
         }
         else
              // not pointing and no location indicated
             {
                 loca2send = "-9";
                 if(data.c_rec[0].equals("palette"))
                 {
                   if(from_palette_s.size()<1)
                    { keepW = true;
                    println("special 1");
                    feedUser = "J attends que vous m indiquiez la couleur. Encore un click !";
                    }
                   else
                    {
                      c_rec[2] = from_palette_c.get(0);
                     }
                   }
                 }
               }
     } 
     else
     // studying cases when action = coloring 
     {
       println("coloring");
       if(data.pointing) // pointing an exact shape 
       {
          if(colorN.equals("palette")) // Poiting a color
          {
            // no pointing pointed color
           switch(data.from_palette_s.size())
             {
             case 2:
               colorN = from_palette_c.get(1);
               shape[2] = from_palette_s.get(0);
               speCase = true;
               exactShape = "0";
               println("spe col");
               break;
             case 1:
               keepW = true; 
               feedUser = "J attends que vous m indiquiez la nouvelle couleur. Encore un click !";             
               break;
             case 0:
               feedUser = "J attends que vous m indiquiez la forme et la nouvelle couleur. Encore 2 clicks !";
               keepW = true;
               break;
             default:
               noMatch = true;
               feedUser = "Trop de clicks ! Je ne comprends pas, je vais recommancer...";
               break;
             }
       }
         else
         {
           switch(data.from_palette_s.size()) // not pointing a color
             {
             case 1:
               shape[2] = from_palette_s.get(0);
               speCase = true;
               exactShape = "0";
               break;
             case 0:
               keepW = true;
               feedUser = "J attends que vous m indiquiez la forme. Encore un click !";
               break;
             default:
               noMatch = true;
               feedUser = "Trop de clicks ! Je ne comprends pas, je vais recommancer...";
               break;
             }
         }
       }
       else // not pointing a shape
       {
         if(colorN.equals("palette"))
          {
            // pointing a color
           switch(data.from_palette_s.size())
             {
             case 1:
               colorN = from_palette_c.get(0);
               break;
             case 0:
               keepW = true;
               feedUser = "J attends que vous m indiquiez la nouvelle couleur. Encore un click !";
               break;
             default:
               noMatch = true;
               feedUser = "Trop de clicks ! Je ne comprends pas, je vais recommancer...";
               break;
             }
          }
       }
     }
     }
       
       println("end of click testing");
       // waiting to get at least one input on shape
       if((shape[0].equals("undefined") && shape[1].equals("undefined") && shape[2].equals("undefined"))) {
            shapeIn = false; 
            keepW = true;
            feedUser = "J attends que vous m indiquiez une forme par le geste. On y est presque !";
          } // wait for at least one shape input
       else
       {
        shapeIn = true;
      // waiting 2.4s to get more inputs on shape for robustness
        if(shape[0].equals("undefined") || shape[1].equals("undefined") || shape[2].equals("undefined"))
          {
            println("another shape maybe");
            //delay(2400); // waiting for other shape input for robustness
          }
       }
        allIn = !keepW && shapeIn;
        println(keepW);
    }
 
    public void dataFuse() {
     /** fusion the input data and generate output data
    */
       if(c_rec[0].equals("palette"))
       {
         c = c_rec[2];
         println("here");
         println(c_rec[2]);
       }
      println("in fusion");
      println(c_rec[0]);
           float max = -1; 
           int index = 0;
           // maximize output's confidence
           for(int i=0;i<numIn;i++) 
           {
             if(max<confi[i] && !shape[i].equals("undefined"))
             {
               max = confi[i];
               index = i;
               println(index);
             }
              if(!(c_rec[i].equals("undefined")) && !(c_rec[0].equals("palette")))
                 c = c_rec[i];
             }
           shape2send = shape[index];   // choosing the most confident shape
           if(!(c_rec[index].equals("undefined")) && !(c_rec[0].equals("palette")))
                 c = c_rec[index];

   }
   
   public void dataSend(){
    /** publishing messages on Ivy bus
    */
    if(data.speCase)
      {
        if(!data.action.equals("o"))
        {
        try {
          bus.sendMsg("mfe action=" + data.action + " shape=" + data.shape2send + " color=" + data.c + " eShape=" + data.exactShape + " local=" + data.loca2send ); 
          }
        catch (IvyException e) {}
        }
        else
        {
        try {
          bus.sendMsg("mfe action=o" +" shape=" + data.shape2send + " color=" + data.c + " eShape=" + data.exactShape + " colorN=" + data.colorN); 
          }
        catch (IvyException e) {}
        }
        }
        
      else {
        if(!data.action.equals("o"))
        {
      try {
          bus.sendMsg("mfe action=" + data.action + " shape=" + data.shape2send + " color=" + data.c + " end local=" + data.loca2send); 
          println(data.loca2send);  
        }
      catch (IvyException e) {}
      }
      else
      {
        try {
          bus.sendMsg("mfe action=o" +" shape=" + data.shape2send + " color=" + data.c + " eShape=-1"  + " colorN=" + data.colorN); 
          }
        catch (IvyException e) {}
        }
      }
      
  }
  
}


  public void settings() { size(525, 100); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FusionEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
