/* autogenerated by Processing revision 1286 on 2022-11-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import fr.dgac.ivy.*;
import fr.dgac.ivy.tools.*;
import gnu.getopt.*;

import java.awt.Point;
import fr.dgac.ivy.*;
import java.io.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Board extends PApplet {



/*
 * Palette Graphique - prélude au projet multimodal 3A SRI
 * 4 objets gérés : cercle, rectangle(carré), losange et triangle
 * (c) 05/11/2019
 * Dernière révision : 28/04/2020
 */
 





ArrayList<Forme> formes; // liste de formes stockées
FSM mae; // Finite Sate Machine
Ivy bus;

PImage sketch_icon; 
PImage img; 

boolean selected_here; // ?
boolean sent;
Instruction data; // instruction data container
int xpos;
int ypos;

List<Integer> x_pos; // stacking the clicks coordinates
List<Integer> y_pos;

 public void setup() {
  // display
  /* size commented out by preprocessor */;
  surface.setResizable(false);
  surface.setTitle("Board");
  surface.setLocation(-10,0);
  sketch_icon = loadImage("Palette.jpg");
  surface.setIcon(sketch_icon);
  img = loadImage("coq.PNG");
  
  // init
  data = new Instruction();
  formes= new ArrayList(); // nous créons une liste vide
  noStroke();
  mae = FSM.INIT;
  selected_here = false;
  xpos = -1;
  ypos = -1;
  x_pos = new ArrayList<Integer>();
  y_pos = new ArrayList<Integer>();

  try {
    bus = new Ivy("Board", "Board is ready", null);
    bus.start("127.255.255.255:2010");
    
    
    
    bus.bindMsg("^mfe action=o shape=(.*) color=(.*) eShape=(.*) colorN=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        println("recep color");
        if(data.start)
        {
          data.recieved = true; 
          data.action_server = 'o';
          data.shape_server = args[0].charAt(0);
          data.c_server = args[1];
          data.locate = -9;
          data.elocate = Integer.valueOf(args[2]);
          if(data.elocate>y_pos.size()-1)
            {
              mae = FSM.DISPLAY_SHAPE;
              data.message = "Un erreur est survenue lors de l'execution. Je dois recommencer.";
            }
          data.newColor= args[3];
          println(data.locate);
        }
      }        
    });
    
    bus.bindMsg("^mfe action=(.*) shape=(.*) color=(.*) eShape=(.*) local=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        if(data.start)
        {
          data.recieved = true; 
          data.action_server = args[0].charAt(0);
          data.shape_server = args[1].charAt(0);
          data.c_server = args[2];
          data.locate = Integer.valueOf(args[4]);
          data.elocate = Integer.valueOf(args[3]);
          
          if(data.elocate>y_pos.size()-1 || data.locate>y_pos.size())
            {
              mae = FSM.DISPLAY_SHAPE;
              data.message = "Un erreur est survenue lors de l'execution. Je dois recommencer.";
            }
          println(data.locate);
          println("exact");
        }
      }        
    });
    
    bus.bindMsg("^mfe action=(.*) shape=(.*) color=(.*) end local=(.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        if(data.start)
        {
          data.recieved = true; 
          data.action_server = args[0].charAt(0);
          data.shape_server = args[1].charAt(0);
          data.c_server = args[2];
          data.locate = Integer.valueOf(args[3]);
          if(data.locate>y_pos.size()-1 )
            {
              mae = FSM.DISPLAY_SHAPE;
              data.message = "Un erreur est survenue lors de l'execution. Je dois recommencer.";
            }
          println(data.locate);
        }
      }        
    });
    
    bus.bindMsg("^sra5 Parsed=1 start=1 (.*)", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        data.reset();
        x_pos.clear();
        y_pos.clear();
        data.start = true;  
        mae = FSM.INIT;
      }        
    });
    
    bus.bindMsg("^mfe cocorico", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        if(data.start)
        {
          data.recieved = true; 
          data.action_server = 'q';
          sent = false;
        }
      }        
    });
    
    bus.bindMsg("OneDollarIvy exit", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        exit();
      }        
    });
    
    bus.bindMsg("^mfe event=abort", new IvyMessageListener()
    {
      public void receive(IvyClient client, String[] args)
      {
        if(data.start)
        {
          mae = FSM.INIT;
          data.reset();
          data.recieved = false;}
      }
    });
    
  }
  catch (IvyException ie) {}
}

 public void draw() {
  background(0);
  switch (mae) {
      
    case INIT:
      // waiting the start signal
      data.result = false;
      x_pos.clear();
      y_pos.clear();
      if(data.start)
        mae = FSM.HOLD;
      affiche();
        break;
    
    case HOLD:
      // waiting message from server
        if(data.recieved){
          data.start = false;
          mae = FSM.MAP_ACTION;
          data.recieved = false;
          if(data.locate ==-9)
            {
              xpos = PApplet.parseInt(random(1) * width);
              ypos = PApplet.parseInt(random(1) * height);
            }
          else
            {
              xpos = x_pos.get(data.locate);
              ypos = y_pos.get(data.locate);
            }
        }
       affiche();
        break;
    
    case MAP_ACTION:
      // map action to state
      switch(data.action_server){
        case 'c':
          // map to create
          mae = FSM.CREATE_SHAPE;
          break;
        
        case 'd':
          // map to delete shape
          mae = FSM.DELETE_SHAPE;
          break;
          
        case 'm':
          // map to move shape
          mae = FSM.MOVE_SHAPE_PROC;
          break;
          
        case 'o':
          // map to move shape
          mae = FSM.COLOR_SHAPE;
          break;
          
        case 'q':
          // map to move shape
          mae = FSM.COCORICO;
          break;
          
        default:
          mae = FSM.DISPLAY_SHAPE;
          data.message = "action not recognised";
          data.message = "L action n est pas repertoriee.";
          break;
      }
      
      affiche();
      break;
    
    case CREATE_SHAPE:
      // target shape creation
      if(!data.c_server.equals("undefined"))
         {  
           data.c_server_list = data.c_server.split("-");
           data.current_c = color(Integer.valueOf(data.c_server_list[0]), Integer.valueOf(data.c_server_list[1]), Integer.valueOf(data.c_server_list[2]));
           }
       else
       { 
         data.current_c = color(random(0,255),random(0,255),random(0,255)); // assign random color if not specified
       }
     Point p;
     p = new Point(xpos, ypos);
     switch(data.shape_server) {
      case 'r':
        Forme f= new Rectangle(p);
        f.setColor(data.current_c);
        formes.add(f);
        data.result = true;
        data.message = "Rectangle created successfully!";
        data.message = "Rectangle créé avec succès !";
        break;
      
      case 'c':
        Forme f2=new Cercle(p);
        formes.add(f2);
        f2.setColor(data.current_c);
        data.result = true;
        data.message = "Circle created successfully!";
        data.message = "Cercle créé avec succès !";
        break;
    
      case 't':
        Forme f3=new Triangle(p);
        formes.add(f3);
        f3.setColor(data.current_c);
        data.result = true;
        data.message = "Triangle created successfully!";
        data.message = "Triangle creé avec succès !";
        break;  
      
      case 'l':
        Forme f4=new Losange(p);
        formes.add(f4);
        f4.setColor(data.current_c);
        data.result = true;
        data.message = "Diamond created successfully!";
        data.message = "Losange créé avec succès !";
        break;    
      
      default : 
        data.result = false;
        data.message = "Shape not recognised. could not draw. Would you want to try again?";
        data.message = "Je ne connais pas cette forme. Voulez vous reessayer?";
        break;
     }
     mae=FSM.DISPLAY_SHAPE;  
     affiche();
     break;
     
    case MOVE_SHAPE_PROC: 
      // search for shape to move or abort moving
       if(data.elocate >-1)
       data.lookForShape(x_pos.get(data.elocate), y_pos.get(data.elocate));
       else
       data.lookForShape(0,0);
     if (data.shape_id == -1)
     {
       mae = FSM.DISPLAY_SHAPE;
       data.message = "Indicated shape not found.";
       data.message = "La forme voulue n existe pas. Je n ai rien pu deplacer.";
       data.result = false;
     }
     else {
       mae = FSM.MOVE_SHAPE;
     }
     break;
     
    case MOVE_SHAPE:
      // move found shape
        Point pp;
        pp = new Point(xpos, ypos);
       (formes.get(data.shape_id)).setLocation(pp); // current location of the mouse
       data.shape_id=-1; // reset
       mae=FSM.DISPLAY_SHAPE;
       data.result = true;
       data.message = "Shape moved succesfully.";
       data.message = "Forme deplacée avec succès !";
       affiche();
       break;
     
     case DELETE_SHAPE:
         // delete target shape
         if(data.elocate >-1)
         data.lookForShape(x_pos.get(data.elocate), y_pos.get(data.elocate));
         else
         data.lookForShape(0,0);
         // prepare feedback
         if (data.shape_id == -1)
         {
           data.result = false;
           data.message = "Indicated shape not found. No action was performed.";
           data.message = "La forme voulue n existe pas. Je n ai rien pu supprimer.";
         }
         else {
           formes.remove(data.shape_id);
           data.message = "Shape deleted succesfully";
           data.message = "La forme a ete supprimee avec succès ! ";
         }
         mae = FSM.DISPLAY_SHAPE;
         break;
         
    case COLOR_SHAPE:
         if(data.elocate >-1)
           data.lookForShape(x_pos.get(data.elocate), y_pos.get(data.elocate));
         else
           data.lookForShape(0,0);
         // prepare feedback
         if (data.shape_id == -1)
         {
           data.result = false;
           data.message = "Indicated shape not found. No action was performed.";
           data.message = "La forme voulue n existe pas. Je n ai rien pu colorier.";
         }
         else {
         String[] newCol;
         int coul;
         if(!data.newColor.equals("undefined"))
         {
           newCol = data.newColor.split("-");
           coul = color(Integer.valueOf(newCol[0]), Integer.valueOf( newCol[1]), Integer.valueOf(newCol[2]));
         }
         else
           coul = color(random(0,255),random(0,255),random(0,255));
           formes.get(data.shape_id).setColor(coul);
           data.message = "Shape colored succesfully";
           data.message = "La forme a ete coloriee avec succès !";
         }
         mae = FSM.DISPLAY_SHAPE;
         break;
         
     case COCORICO:   // shape update made by the drawing function
        //mae = FSM.INIT;
        data.shape_id = -1;
        data.reset();
        x_pos.clear();
        y_pos.clear();
        if(!sent)
        {
          try {
          bus.sendMsg("Board result=cocorico Allez les bleus !");
        }
        catch (IvyException ie) {}
        sent = true;
        }
         break;
   
    case DISPLAY_SHAPE:   // shape update made by the drawing function
      try {
          bus.sendMsg("Board result="+data.message);
        }
        catch (IvyException ie) {}
        mae = FSM.INIT;
        data.shape_id = -1;
        data.reset();
        x_pos.clear();
        y_pos.clear();
         break;
        
    default:
      break;
  }
  if(mae == FSM.COCORICO)
  {
   image(img, 250,250,200,200);
     //mae = FSM.INIT;
  }
    text("** ETAT COURANT **", 20,20);
  if(mae == FSM.INIT)
    text(0, 20, 50);
  if(mae == FSM.HOLD)
    text(1, 20, 50);
  if(mae == FSM.MAP_ACTION)
    text(2, 20, 50);
  if(mae == FSM.CREATE_SHAPE)
    text(3, 20, 50);
  if(mae == FSM.DISPLAY_SHAPE)
    text(-1, 20, 50);
}

// fonction d'affichage des formes m
 public void affiche() {
  background(255);
  /* afficher tous les objets */
  for (int i=0;i<formes.size();i++) // on affiche les objets de la liste
    (formes.get(i)).update();
}

 public void mousePressed() { // sur l'événement click
  
  switch (mae) {
    case HOLD: 
      x_pos.add(mouseX);
      y_pos.add(mouseY);
      int index = -1;
      Point p = new Point(x_pos.get(x_pos.size()-1), y_pos.get(y_pos.size()-1));
      // send pointed shape to server
      for (int i=0;i<formes.size();i++) { // we're trying every object in the list
        if ((formes.get(i)).isClicked(p)) {
          //(formes.get(i)).setColor(color(random(0,255),random(0,255),random(0,255)));
          index = i;
          //println("boolean ", ((formes.get(i)).c == (formes.get(i)).c));
        }
      } 
      if( index != -1) {
        println("couleur ivy");
        println((formes.get(index)).getColorString());
        selected_here = true;
        try {
          bus.sendMsg("Board shape=" + (formes.get(index)).getType() + " color="+(formes.get(index)).getColorString()+ " Confidence=" + String.format("%.2f", 1.0f));
        }
        catch (IvyException ie) {}
       }
      else {
        println("couleur ivy");
        selected_here = true;
        try {
          bus.sendMsg("Board shape=undefined color=undefined Confidence=" + String.format("%.2f", 1.0f));
        }
        catch (IvyException ie) {}
       }
      break;
  
    default:
      break;
  }
}
/*
 * Classe Cercle
 */ 
 
public class Cercle extends Forme {
  
  int rayon;
  
  public Cercle(Point p) {
    super(p);
    this.type = 'c';
    this.rayon=80;
  }
   
  public void update() {
    fill(this.c);
    circle((int) this.origin.getX(),(int) this.origin.getY(),this.rayon);
  }  

   
   public boolean isClicked(Point p) {
    // vérifier que le cercle est cliqué
   PVector OM= new PVector( (int) (p.getX() - this.origin.getX()),(int) (p.getY() - this.origin.getY())); 
   if (OM.mag() <= this.rayon/2)
     return(true);
   else 
     return(false);
  }
  
  protected double perimetre() {
    return(2*PI*this.rayon);
  }
  
  protected double aire(){
    return(PI*this.rayon*this.rayon);
  }
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 *
 */
 
public enum FSM {
  INIT, // waiting speech to start
  HOLD, // wait instruction from server
  MAP_ACTION, // map the target action to state
  MOVE_SHAPE_PROC, // find target shape to move
  MOVE_SHAPE, // move target shape
  DISPLAY_SHAPE, // display palette
  DELETE_SHAPE, // delete shape
  CREATE_SHAPE, // create shape
  COLOR_SHAPE, // change shape color
  COCORICO
}
/*****
 * Création d'un nouvelle classe objet : Forme (Cercle, Rectangle, Triangle
 * 
 * Date dernière modification : 28/10/2019
 */

abstract class Forme {
 Point origin;
 int c;
 char type;
 
 Forme(Point p) {
   this.origin=p;
   this.c = color(127);
   this.type ='_';
 }
 
  public void setColor(int c) {
   this.c=c;
 }
 
  public int getColor(){
   return(this.c);
 }
 
  public String getColorString(){
   String col = hex(this.c);
   int r = unhex(col.substring(2,4));
   int v = unhex(col.substring(4,6));
   int b = unhex(col.substring(6,8));
   return String.valueOf(r)+'-'+String.valueOf(v)+'-'+String.valueOf(b);
 }
 
   public char getType(){
   return(this.type);
 }
 
  public abstract void update();
 
  public Point getLocation() {
   return(this.origin);
 }
 

 
  public void setLocation(Point p) {
   this.origin = p;
 }
 
  public abstract boolean isClicked(Point p);
 
 // Calcul de la distance entre 2 points
 protected double distance(Point A, Point B) {
    PVector AB = new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    return(AB.mag());
 }
 
 protected abstract double perimetre();
 protected abstract double aire();
}
public class Instruction {
  int shape_id; // index of the pointed shape
  char action_server; // target action
  char shape_server; // target shape
  String c_server; // target color in string
  String[] c_server_list; // target R G B fields
  int current_c; // pointed color
  boolean start; // start signal
  boolean recieved; // recieved instruction from server
  boolean result; // excution feedback
  String message; // message to publish
  int locate;
  int elocate;
  String newColor;
  
  public Instruction() {
    shape_id = -1;
    start = false; //start of execution
    recieved=false;
    result = false;
    locate = -9;
    elocate = -1;
    message = "";
    newColor = "";
    c_server_list = new String[3];
    action_server = shape_server = ' ';
    c_server = "";
  }
  
   public void reset()
  {
    shape_id = -1;
    start = false; //start of execution
    recieved=false;
    result = false;
    locate = -9;
    elocate = -1;
    message = "";
    newColor = "";
    c_server_list = new String[3];
    action_server = shape_server = ' ';
    c_server = "";
  }
  
   public int lookForShape(int x,int y) {
    if(data.elocate <0)
    {
    if(!c_server.equals("undefined"))
       {
           c_server_list = c_server.split("-");
           current_c = color(Integer.valueOf(c_server_list[0]), Integer.valueOf( c_server_list[1]), Integer.valueOf(c_server_list[2]));
           for (int i=0; i<formes.size(); i++) { // we're trying every object in the list        
            if ((formes.get(i)).getType() == shape_server && (formes.get(i)).c == current_c) {
              shape_id = i;
            }         
           }
       }
       else
       {
         for (int i=0; i<formes.size(); i++) { // we're trying every object in the list        
            if ((formes.get(i)).getType() == shape_server) {
              shape_id = i;
            }  
         }
       }
    }
    else
    {
      Point p = new Point(x, y);
      // send pointed shape to server
      for (int i=0;i<formes.size();i++) { // we're trying every object in the list
        if ((formes.get(i)).isClicked(p)) {
          //(formes.get(i)).setColor(color(random(0,255),random(0,255),random(0,255)));
          data.shape_id = i;
          //println("boolean ", ((formes.get(i)).c == (formes.get(i)).c));
        }
      }
      println("passing in spe");
    }
    
    return shape_id;
    
  }


}
/*
 * Classe Losange
 */ 
 
public class Losange extends Forme {
  Point A, B,C,D;
  
  public Losange(Point p) {
    super(p);
    // placement des points
    this.type = 'l';
    A = new Point();    
    A.setLocation(p);
    B = new Point();    
    B.setLocation(A);
    C = new Point();  
    C.setLocation(A);
    D = new Point();
    D.setLocation(A);
    B.translate(40,60);
    D.translate(-40,60);
    C.translate(0,120);
    
  }
  
   public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      D.setLocation(A);
      B.translate(40,60);
      D.translate(-40,60);
      C.translate(0,120);   
  }
  
  public void update() {
    fill(this.c);
    quad((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY(),  (float) D.getX(),  (float) D.getY());
  }  
  
   public boolean isClicked(Point M) {
    // vérifier que le losange est cliqué
    // aire du rectangle AMD + AMB + BMC + CMD = aire losange  
    if (round( (float) (aire_triangle(A,M,D) + aire_triangle(A,M,B) + aire_triangle(B,M,C) + aire_triangle(C,M,D))) == round((float) aire()))
      return(true);
    else 
      return(false);  
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector CD= new PVector( (int) (D.getX() - C.getX()),(int) (D.getY() - C.getY())); 
    PVector DA= new PVector( (int) (A.getX() - D.getX()),(int) (A.getY() - D.getY())); 
    return( AB.mag()+BC.mag()+CD.mag()+DA.mag()); 
  }
  
  protected double aire(){
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BD= new PVector( (int) (D.getX() - B.getX()),(int) (D.getY() - B.getY())); 
    return((AC.mag()*BD.mag())/2);
  } 
  
  private double perimetre_triangle(Point I, Point J, Point K) {
    //
    PVector IJ= new PVector( (int) (J.getX() - I.getX()),(int) (J.getY() - I.getY())); 
    PVector JK= new PVector( (int) (K.getX() - J.getX()),(int) (K.getY() - J.getY())); 
    PVector KI= new PVector( (int) (I.getX() - K.getX()),(int) (I.getY() - K.getY())); 
    
    return( IJ.mag()+JK.mag()+KI.mag()); 
  }
   
  // Calcul de l'aire d'un triangle par la méthode de Héron 
  private double aire_triangle(Point I, Point J, Point K){
    double s = perimetre_triangle(I,J,K)/2;
    double aire = s*(s-distance(I,J))*(s-distance(J,K))*(s-distance(K,I));
    return(sqrt((float) aire));
  }
}
/*
 * Classe Rectangle
 */ 
 
public class Rectangle extends Forme {
  
  int longueur;
  
  public Rectangle(Point p) {
    super(p);
    this.type = 'r';
    this.longueur=60;
  }
   
  public void update() {
    fill(this.c);
    square((int) this.origin.getX(),(int) this.origin.getY(),this.longueur);
  }  
  
   public boolean isClicked(Point p) {
    int x= (int) p.getX(); // coordinates of the clicked point in the palette display window
    int y= (int) p.getY();
    int x0 = (int) this.origin.getX();
    int y0 = (int) this.origin.getY();
    
    // vérifier que le rectangle est cliqué
    if ((x>x0) && (x<x0+this.longueur) && (y>y0) && (y<y0+this.longueur))
      return(true);
    else  
      return(false);
  }
  
  // Calcul du périmètre du carré
  protected double perimetre() {
    return(this.longueur*4);
  }

  
  protected double aire(){
    return(this.longueur*this.longueur);
  }
}
/*
 * Classe Triangle
 */ 
 
public class Triangle extends Forme {
  Point A, B,C;
  public Triangle(Point p) {
    super(p);
    this.type = 't';
    // placement des points
    A = new Point();    
    A.setLocation(p);
    B = new Point();    
    B.setLocation(A);
    C = new Point();    
    C.setLocation(A);
    B.translate(40,60);
    C.translate(-40,60);
  }
  
     public void setLocation(Point p) {
      super.setLocation(p);
      // redéfinition de l'emplacement des points
      A.setLocation(p);   
      B.setLocation(A);  
      C.setLocation(A);
      B.translate(40,60);
      C.translate(-40,60);   
  }
  
  public void update() {
    fill(this.c);
    triangle((float) A.getX(), (float) A.getY(), (float) B.getX(), (float) B.getY(), (float) C.getX(), (float) C.getY());
  } 
  
  
   public boolean isClicked(Point M) {
    // vérifier que le triangle est cliqué
    
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector AM= new PVector( (int) (M.getX() - A.getX()),(int) (M.getY() - A.getY())); 
    
    PVector BA= new PVector( (int) (A.getX() - B.getX()),(int) (A.getY() - B.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    PVector BM= new PVector( (int) (M.getX() - B.getX()),(int) (M.getY() - B.getY())); 
    
    PVector CA= new PVector( (int) (A.getX() - C.getX()),(int) (A.getY() - C.getY())); 
    PVector CB= new PVector( (int) (B.getX() - C.getX()),(int) (B.getY() - C.getY())); 
    PVector CM= new PVector( (int) (M.getX() - C.getX()),(int) (M.getY() - C.getY())); 
    
    if ( ((AB.cross(AM)).dot(AM.cross(AC)) >=0) && ((BA.cross(BM)).dot(BM.cross(BC)) >=0) && ((CA.cross(CM)).dot(CM.cross(CB)) >=0) ) { 
      return(true);
    }
    else
      return(false);
  }
  
  protected double perimetre() {
    //
    PVector AB= new PVector( (int) (B.getX() - A.getX()),(int) (B.getY() - A.getY())); 
    PVector AC= new PVector( (int) (C.getX() - A.getX()),(int) (C.getY() - A.getY())); 
    PVector BC= new PVector( (int) (C.getX() - B.getX()),(int) (C.getY() - B.getY())); 
    
    return( AB.mag()+AC.mag()+BC.mag()); 
  }
   
  // Calcul de l'aire du triangle par la méthode de Héron 
  protected double aire(){
    double s = perimetre()/2;
    double aire = s*(s-distance(B,C))*(s-distance(A,C))*(s-distance(A,B));
    return(sqrt((float) aire));
  }
}


  public void settings() { size(900, 1010); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Board" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
